<!DOCTYPE HTML PUBLIC "4.01 Transitional">
<html>
<title>newLISP  v.10.0 Release Notes </title>
<body>
<blockquote><h1>newLISP<font size=-2>&#174;</font> v.10.0.1 Release Notes 
<font size=-1>January 8th, 2009</font></h1>

<p>Version 10.0.1 is a maintenance update to release 10.0.1. Some minor
feature enhancements are noted in the next (search for 10.0.1).</p>

<p>newLISP version 10.0 marks a new generation of newLISP with new abilities, such as
reference returns instead of copies for many built-in functions and a
generalized method to modify lists, arrays and strings in-place. Version 10.0
is also a cleanup and streamlining of functionality added during the 8.x and 9.x series 
of releases. </p>

<p>Other details in the built-in functions API have been changed to make 
functions work better together. Use the <a href="#guide">conversion guide</a>
at the end of these release notes to help you convert existing files for use with 
newLISP 10.0.</p>

<p>The changes introduce incompatibilities with the previous versions of releases. 
Any production source running on the new generation of newLISP should be carefully 
checked against these release notes.</p>

<p>Many thanks to the community of newLISP users for their ideas and contributions.</p>

<h3>Reference returns</h3>

<p>Any built-in function returning a list, array or string, or an element of
a list, array or string, will return a reference and not a copy if the list or 
array is bound to a symbol. Destructive functions can now work on the return value 
of other functions modifying the original list, array or string.
The new <tt>setf</tt> can be used to modify an element of a list, array or 
string referencing it via one of the many available list, array and string 
accessors:</p>
    
<blockquote><pre>
(set 'lst '(a b c))
(setf (first lst) 99)
lst &rarr; (99 b c)
  
(setf (lst -1) 'C)
lst &rarr;  (99 b C)
  
(set 'A '((a 1) (b 2) (c 3)))
(push 'z (assoc 'c A))
A &rarr; ((a 1) (b 2) (z c 3))
      
(set 'L '(a b (c d e f g)))
(= (replace 'f (nth (+ 1 1) L) 'z) '(c d e z g))
(= L '(a b (c d e z g)))

(setq s "abc")
(setf (s -1) "C")
(setf (nth 1 s) "B")
(setf (first s) "The A")
s &rarr; "The ABC"
</pre></blockquote>
                               
<p>The following functions return a reference to the list, array or string
or element of a list or array, which can be modified by other functions. 
Previously these functions returned a copy (with the exception of <tt>set</tt>):</p>
  
<blockquote>  
<tt>assoc, first, last, lookup, ntn, replace, reverse, rotate, set, setf
setq, set-ref, set-ref-all, sort, swap</tt>
</blockquote>

<p>All control structures without local variables maintain a reference for the
last returned value in the statement block, if that value was a reference:</p>

<blockquote>
<tt>amb</tt>, <tt>begin</tt>, <tt>if</tt>, <tt>if-not</tt>, <tt>when</tt>, 
<tt>unless</tt>, <tt>while</tt>, <tt>until</tt>,  <tt>do-while</tt>, 
<tt>do-until</tt>, <tt>cond</tt> and <tt>case</tt>.
</blockquote>

... and added in v.10.0.1:

<blockquote>
<tt>for</tt>, <tt>doargs</tt>, <tt>dolist</tt>, <tt>dostring</tt>, 
<tt>dotimes</tt>, <tt>dotree</tt>.
</blockquote>

<p>Now all built-in functions except <tt>let</tt>, <tt>letn</tt>, <tt>letx</tt> and
<tt>local</tt> can return references.</p>

<p>To force the return of a copy instead of a reference, enclose the expression 
in the new <tt>copy</tt> function:</p>

<blockquote><pre>
; sort a copy not the original list
(sort (copy myList))
</pre></blockquote>

<p>Normally there are few places in program code that rely on returning copies. 
In fact, the new possibility to work directly
on returned references will give many opportunities to write terser and 
speedier code.</p>

<h3>Functions <tt>setf</tt> and <tt>copy</tt></h3>

<p><tt>setf</tt> is a new function working not only on symbol references 
like <tt>setq</tt> but also on any reference returned from an expression. The function
is well known under the same name in other Lisp dialects and works in a similar way.
<tt>setq</tt> and the new <tt>setf</tt> both point to the same internal code 
and are interchangeable. It is recommended to use <tt>setq</tt> for setting symbol 
variables and use <tt>setf</tt> whenever a sublist, sub array or substring is referenced, 
Note that any list, array or string changed must be anchored in a symbol referencing it. 
If no reference is found, an error message is returned:

<blockquote><pre>
(setq l1 '(a b c))
(setq l2 '(d e f))

(setf 1 (append l1 l2) 99)
ERR: no symbol reference found in function setf
</pre></blockquote>

<p>Allthough the partial lists are anchored in <tt>l1</tt> and <tt>l2</tt>
the return value from the <tt>append</tt> function is not referenced by any 
symbol and cannot be used by <tt>setf</tt>.</p>

<p>To make destructive functions non-destructive, a new <tt>copy</tt> function
has been introduced:</p>

<blockquote><pre>
(replace elmnt (copy aList) newElmnt)
</pre></blockquote>

<p>In the example <tt>aList</tt> will not be changed although <tt>replace</tt>
is destructive.</p>

<h3>Anaphoric system variable <tt>$it</tt></h3>

<p>The new system variable <tt>$it</tt> is used when doing self-referential
assignments in <tt>setf</tt> and hashes. It can also be used in many cases
as an alternative choice where the system variable <tt>$0</tt> is used.</p>

<blockquote><pre>
(setq lst '(1 2 3 4))
(setf (lst 2) (* $it 10)) 
lst &rarr; (1 2 30 4)

(setq str "abc")
(setf (str -1) (dup $it))
str &rarr; "abcc"

(MyHash "var" "hello")
(MyHash "var" (upper-case $it))
(MyHash &rarr; "HELLO")
</pre></blockquote>

<p>The functions <tt>find-all</tt>, <tt>replace</tt>, <tt>set-ref</tt> and 
<tt>set-ref-all</tt> use <tt>$it</tt> as an alternative choice to <tt>$0</tt>.</p>

<p>The difference between <tt>$it</tt> and <tt>$0</tt> is that <tt>$it</tt>
will not retain the value beyond the evaluation of the self-referential expression 
it is part of, while <tt>$0</tt> retains the value until used in another 
expression. <tt>$it</tt> is read-only, while <tt>$0</tt> can be set by the user.
Neither <tt>$it</tt> nor <tt>$0 - $15</tt> are reentrant. Another subexpression
using these variables will change them too.</p>

<h3>Removed functions</h3>

<p>The new <tt>setf</tt> function makes the functions <tt>set-assoc</tt>, 
<tt>assoc-set</tt>, <tt>set-nth</tt>, <tt>nth-set</tt> and <tt>ref-set</tt> 
obsolete. These functions have been removed. The <tt>integer</tt> function, 
deprecated since a few years, has been removed, and the shorter writing <tt>int</tt>
should be used instead. The last section in this release notes 
gives examples of how to convert code to use the new or modified functions.</p>

<h3>Changes in indexing syntax</h3>  
  
<p>The parenthesized syntax for <tt>assoc</tt> <tt>nth</tt> <tt>ref</tt> <tt>set-ref</tt> 
and <tt>set-ref-all</tt> has been eliminated. Only the traditional flat syntax is allowed. 
Note that the parenthesized syntax should not be confused with the syntax used in
<em>implicit indexing</em>. In the abolished parenthesized syntax, the parentheses
were <em>syntactical sugar</em> similar to parentheses used in the <tt>dotimes</tt>
or <tt>for</tt> forms. The following example illustrates this:</p>

<blockquote><pre>
(nth (theList idx)) ; parenthesized syntax

(setf (theList idx) value) ; implicit indexing syntax
</pre></blockquote>

<p>In the first line the inner parentheses are part of a special form syntax.
In the second example all parentheses are part of s-expressions.</p>

<p>When multiple indices or keys are used, a list is specified instead of a 
single index or key:</p>

<blockquote><pre>  
(nth i myList)             ; single index, flat form
(myList i)                 ; single index implicit index form
(nth idxList myList)       ; multiple indices, flat form
(myList idx1 idx2 ... )    ; multiple indices, implicit index, flat indices
(myList idxList)           ; multiple indices, inplicit index, index vector

(assoc key aList)          ; single key
(assoc list-of-keys aList) ; multiple key
</pre></blockquote>  
  
<p>Index list vectors are the same as those returned by <tt>ref</tt> and <tt>ref-all</tt>. 
Index vectors have been supported by <tt>pop</tt> and <tt>push</tt> for several years. 
Index vectors tie together <tt>nth</tt>, <tt>ref</tt>, <tt>ref-all</tt>, <tt>push</tt>
and <tt>pop</tt>. Using index vectors in impicit indexing and the syntax of 'nth' gives 
'nth' a uniform parameter <em>arity</em> regardless of the number of indices involved.</p>
  
<h3>Other changes in functions</h3>  

<ul>
<li><tt>bits</tt> is a new function returning the binary representation of a number.</li>
<li><tt>dec</tt> does not need the quote before a symbol and also can decrement
places like <tt>setf</tt> does.</li>

<li><tt>callback</tt> now can pass up to eight parameters (before four). Sixteen
callback functions can be assigned (before eight) v.10.0.1.</li>

<li><tt>default</tt> returns the contents of a default functor when given a context. 
This function was not documented since v9.4.5. It was previously documented in version
9.3, but now works differently.</li>

<li><tt>env</tt> when given without any parameters, now returns an association
list. Before, a flat list of environment strings, e.g. "KEY=value" was returned.</li>

<li><tt>eval-string</tt> has reversed the order of the context and error-handler
parameters. The error-handler is now the last optional parameter.<br></li>

<li><tt>file-info</tt> takes an additional flag to force stats for the original
file when the file-node checked is a link.</li>

<li><tt>inc</tt> does not need the quote before a symbol and also can increment
places like 'setf' does.</li>

<li><tt>lookup</tt> can now take multiple keys similar to <tt>assoc</tt>.<br></li>

<li><tt>net-interface</tt> This new function allows the user to define the default network
interface to be used by other network functions on multihomed machines with multiple
IP numbers.</li>

<li><tt>net-receive</tt> no longer needs the quote before the buffer symbol. It also
accepts a default functor specified by a context name as a buffer, for reference
passing in and out of user-defined functions.</li>

<li><tt>(nth str 0)</tt> and  <tt>(nth str -1)</tt>  will return the empty
string <tt>""</tt> is <tt>str</tt> is the empty string <tt>""</tt>. Before
an <tt>i</tt> index also returned the empty list. Now an out-of-bounds error
will be thrown.<br></li> 

<li><tt>push</tt> now returns the modified list instead of the element pushed.
This modification makes more sense when having reference returns. It can be used to 
model queues: <tt>(pop (push tail Q -1)) =&gt; head</tt></li>

<li><tt>read-expr</tt> has a revised syntax identical to the syntax pattern
of <tt>eval-string</tt>. The workings of <tt>read-expr</tt> have changed too
(see the Reference manual for details). Version 10.0.1 adds an additional
offset parameter for the source.<br></li>
    
<li><tt>read-buffer</tt> no longer needs the quote before the buffer symbol. It also
accepts a default functor specified by a context name as a buffer, for reference
passing in and out of user-defined functions.</li>

<li><tt>set</tt> and <tt>setq</tt> will not allow a missing value argument as 
was tolerated in previous versions.<br></li>

<li><tt>set-locale</tt> now returns a list of locale string and decimal point character,
previously only the locale string was returned.</li>

<li><tt>sys-error</tt> can return the error text when supplying the number 
in version 10.0.1.</li>

<li><tt>unless</tt> is reintroduced, and works like <tt>(when (not ...) ...)</tt>
 with no <em>alternate</em> clause.<br></li>

<li><tt>write-buffer</tt> a never-used odd symbol syntax for the string to be 
written has been eliminated.</li>

<li><tt>write-line</tt> swapped parameters, which are now in the same order as the other write 
functions, with the device parameter coming first. If the second parameter is omitted
the contents of <tt>(current-line)</tt> will be written to the device specified.</li>

<li>Several new file extensions and media MIME types have been added to
the HTTPD mode of newLISP in server mode. See the manual for details.<br></li>

<li>The initialization file in either <tt>$HOME/.init.lsp</tt> or 
<tt>$USERPROFILE/.init.lsp</tt> or <tt>$DOCUMENT_ROOT/.init</tt> is loaded if it 
exists, else if <tt>$NEWLISPDIR/init.lsp</tt> exists, it is loaded.<br></li>

<li>A new environment variable <tt>NEWLISPLIB_INIT</tt> controls loading of
an initialization file for newLISP shared libraries <tt>newlisp.so</tt> or 
<tt>newlisp.dll</tt>. Only if this variable is defined containing the full
path name of an initialization file, the shared library will load it on startup.
</li>

<li>A new command line switch <b><tt>-n</tt></b> can be used to suppress loading any
initialization file when starting newLISP.</li>

<li>When using newLISP interactively in a UNIX shell (i.e. Mac OS X, Linux), <tt>TAB</tt> 
and double <tt>TAB</tt> work as keyword completion for built-in functions. On some UNIX 
systems running the Bash shell, keyboard macros can be defined in <tt>.inputrc</tt> or 
<tt>/etc/inputrc</tt>.</li>

</ul>


<h3>Changed Lisp source files</h3>

<p>Although all old code should be thoroughly investigated for incompatibilities
many newLISP source files will be compatible with version 10.0 without any 
changes. The following files needed minor changes.</p>

<blockquote>
<table border="1" summary="changed source file">
<tr><td><tt>exmples/client</tt></td><td>&nbsp;TCP/IP client example script</td></tr>
<tr><td><tt>exmples/finger</tt></td><td>&nbsp;TCP/IP finger example script</td></tr>
<tr><td><tt>exmples/server</tt></td><td>&nbsp;TCP/IP server example script</td></tr>
<tr><td><tt>exmples/sqlite.cgi</tt></td><td>&nbsp;SQLite3 CGI example script</td></tr>
<tr><td><tt>example/tcltk.lsp</tt></td><td>&nbsp;TclTk example</td></tr>
<tr><td><tt>example/udp-client.lsp</tt></td><td>&nbsp;UDP client example</td></tr>
<tr><td><tt>example/udp-server.lsp</tt></td><td>&nbsp;UDP server example</td></tr>
<tr><td><tt>example/upload.cgi</tt></td><td>&nbsp;CGI file upload example</td></tr>
<tr><td><tt>modules/ftp.lsp</tt></td><td>&nbsp;ftp module</td></tr>
<tr><td><tt>modules/postscript.lsp</tt></td><td>&nbsp;postscript module</td></tr>
<tr><td><tt>modules/stat.lsp</tt></td><td>&nbsp;statistics module (v.10.0.1)</td></tr>
<tr><td><tt>modules/xmlrpc-client.lsp</tt></td><td>&nbsp;XML RPC client module</td></tr>
<tr><td><tt>util/newlispdoc</tt></td><td>&nbsp;documentation generator (v.10.0.1)</td></tr>
<tr><td><tt>util/syntax.lsp</tt></td><td>&nbsp;syntax highlighter</td></tr>
<tr><td><tt>guiserver/newlisp-edit.lsp</tt></td><td>&nbsp;The editor in newLISP-GS</td></tr>
<tr><td><tt>guiserver/pinballs-demo.lsp</tt></td><td>&nbsp;A demo file in newLISP-GS</td></tr>
</table>
</blockquote>

<br><center>&sect;</center></br>

<a name="guide"></a>
<center><h2>Conversion Guide</h2></center>

<h3>Conversion of eliminated and changed functions</h3>

<p><b><tt>set-nth</tt>, <tt>nth-set</tt>, <tt>set-assoc</tt>, <tt>assoc-set</tt></b> must be replaced by a combination of the new <tt>setf</tt> and <tt>nth</tt>, <tt>assoc</tt>.
</p>

<blockquote><pre>   
(nth-set (data idx) value) 
(nth-set idx data value)
(set-nth (data idx) value)
(set-nth idx data value)

; change to one of the following
(setf (nth idx data) value)
(setf (data idx) value)

(set-assoc (aList key) value)
; change to
(setf (assoc key aList) value)
</pre></blockquote>

<p><tt>data</tt> is either a list or array or a string. <tt>idx</tt> is either a
single number or a list of numbers.</p>
   
<p><b>Multiple indices</b> have to be put in a vector, and/or use implicit indexing:</p>
   
<blockquote><pre>   
; old obsolete indexing
(nth i j k data)
(nth (data i j k))

; change to one of the following
(nth (list i j k) data) 
(data (list i j k))
(data i j k)
</pre></blockquote>

<p><tt>data</tt> is either a list or an array, because strings are one-dimensional.</p>

<p>The conversion of eliminated functions will typically not be overlooked, because
programs will throw errors when running into undefined functions. More subtle are
the following changes which could escape detection if the code is not tested carefully</p>

<p><b>Nested expressions</b> of built-in destructive functions must not rely on functions
to return a copy. E.g. in previous versions, after <tt>(pop (sort myList))</tt>, <tt>myList</tt>
was sorted, but the <tt>pop</tt> of the first element happened on a copy:</p>

<blockquote><pre>   
(set 'myList '(a b c d))
       
; in 9.4.5 and earlier
(pop (sort myList)) &rarr; a
myList &rarr; (a b c d) 
   
; in 10.0
(pop (sort myList)) &rarr; a
myList &rarr; (b c d)

</pre></blockquote>

<p>To restore the old behavior and make functions non-destructive, use <tt>copy</tt>:
</p>

<blockquote><pre>   
; restore old non-destructive behavior in nested expressions
(set 'myList '(b d c a))
(pop (copy (sort myList)))
L &rarr; '(b d c a)
</pre></blockquote>

<p><b><tt>dec</tt></b> take away the quote before the symbol.</p>
       
<p><b><tt>env</tt></b> without any parameters now returns an association list. To get
the old behavior, use <tt>(exec "env")</tt> returning a flat list of environment 
strings:</p>

<blockquote><pre> 
; new return value
(env) &rarr; (("PATH" "/usr/bin:/bin:/usr/sbin:/sbin") ...)

; return old format
(exec "env") &rarr; ("PATH=/usr/bin:/bin:/usr/sbin:/sbin" ...)
</pre></blockquote>

<p><b><tt>eval-string</tt></b> has swapped the order of the error-handler and context
parameters:</p>

<blockquote><pre> 
; in 9.4.5 and earlier
(eval-string theString error-handler the-context)

; in 10.0
(eval-string theString the-context error-handler)
</pre></blockquote>

<p>Both the error-handler and context parameter are optional. The context parameter
is usually the one used more frequently.</p>

<p><b><tt>inc</tt></b> take away the quote before the symbol.</p>

<p><b><tt>integer</tt></b> replace with the shorter written <tt>int</tt>.</p>

<p><b><tt>net-receive</tt></b> take away the quote before the buffer symbol.</p>

<p><b><tt>push</tt></b> now returns the modified list instead of the element pushed.
Little code seems to rely on the element pushed as the return value. In many circumstances
explicit list returns in user-defined functions can be eliminated:</p>

<blockquote><pre> 
(define (foo ...)
    ...
   (push x aList)
    aList)
    
; can be modified to

(define (foo ...)
    ...
    (push x aList)) 
</pre></blockquote>

<p><b><tt>set-locale</tt></b> now returns a list of locale string and decimal point character.
Previously only the local string was returned. Code expecting the old return value
can wrap the return value as in <tt>(first (set-locale ... ))</tt>.</p>

<p><b><tt>read-buffer</tt></b> take away the quote before the buffer symbol.</p>

<p><b><tt>read-expr</tt></b> has changed the order of parameters and also changed functionality.
Please consult the reference manual for details.</p>

<p><b><tt>unless</tt></b> has lost the <em>alternate</em> clause. If there was no alternate clause, conversion is not necessary, but all instances of <tt>unless</tt>
containing an alternate clause should be converted to <tt>if-not</tt>, which was introduced 
in version 9.4.5.</p>

<p><b><tt>write-line</tt></b> has swapped parameters to 
<tt>(write-line &lt;device&gt; &lt;string&gt;)</tt> order,
the same as other <tt>write-</tt> functions. The behavior has changed when the second
parameter is missing, see the reference manual for details.</p> 

<p>The order of loading <b><tt>$HOME/.init.lsp</tt></b> and <tt>$NEWLISPDIR/init.lsp</tt>
has changed. The new version will look first for <tt>$HOME/.init.lsp</tt> and
not load <tt>$NEWLISPDIR/init.lsp</tt> if <tt>$HOME/.init.lsp</tt> could be 
loaded. <tt>$NEWLISPDIR/init.lsp</tt> is only loaded is <tt>$HOME/.init.lsp</tt> 
does not exist.</p>

<p>Shared libraries <b><tt>newlisp.so</tt></b> or <b><tt>newlisp.dll</tt></b> only
load a file specified with its full path in the new environment variable 
<tt>NEWLISPLIB_INIT</tt>.</p>

<center>&part;</center>

</blockquote>
</body>
</html>
