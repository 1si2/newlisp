; test big integer operators

(unless bigint
    (println "big integers not enabled in this version")
    (exit))

;; check embedded bigint 0's

(set 'nums '(
; aligned
 12345678901000000000L
 123456789010000000001234567890L
 123456789010000000000000000001234567890L
 123456789010000000000000000000L
 123000000000000000000000000000L
 123000000000000000001L
; not aligned
 123456789010000000000L
 1234567890100000000001234567890L
 1234567890100000000000000000000L
 1230000000000000000000000000000L
 1230000000000000000001L
 1234578901000000000L
 12345789010000000001234567890L
 12345789010000000000000000000L
 123000000000000000000000000L
 123000000000000001L
))

(dolist (num nums)
    (unless (= (/ num 1) num)
        (println num)
        (println ">>>>> ERROR in big integer zeros")
        (exit))
)

; some special cases
(unless (and
    (= (/ 1234567890123456789012345678901234567890 12345678901234567890) 100000000000000000001L)
    (= (/ 1234567890L 12345L) 100005L)
    (= (/ 1234567891L 1234567890L) 1L)
    (= (/ 1234567890L 1234567890L) 1L)
    (= (/ 888888888888888888888888888888888888888888888888888888888888888888888888
          888888888888888888888888888888888888888888888888888888888888889) 999999999L)
    (= (/ 888888888888888888888888888888888888888888888888888888888888888888888888
          888888888888888888888888888888888888888888888888888888888888888) 1000000000L)
    (= (/ 888888888888888888888888888888888888888888888888888888888888888888888888
          888888888888888888888888888888888888888888888888888888888888887) 1000000000L)
    (= (/ 11111111111111111L 11111111111111111L) 1L) ; problems with gcc optimizations on Linux
    (= (/ 22222222222222222L 22222222222222222L) 1L) 
    (= (/ 44444444444444444L 44444444444444444L) 1L) 
    (= (/ 88888888888888888L 88888888888888888L) 1L) 
    (= (/ 99999999999999999L 99999999999999999L) 1L)  )
        (println ">>>>> ERROR in special cases")
            (exit)
)

(seed 5212011)

(if (> (length (main-args)) 2)
    (set 'N (int (main-args -1)))
    (set 'N 100000))

(dotimes (i N)
    (set 'f (pow (random 10 100) (+ 15 (rand 50))))
    (set 'f1 (float (bigint f)))
    (print i "      \r")
    (unless (< (abs (sub (abs (div f f1)) 1)) 0.000000000000001)
       (println f "   " f1 " " (abs (sub (abs (div f f1)) 1)))
       (println ">>>>> ERROR in big integer/float conversion")
       (exit))
)

(define (get-bignum n , num)
    (set 'num (amb "-" ""))
    (if (zero? n) (++ n))
    (dotimes (i n)
        (extend num (string (+ (rand 1000) 1))))
    (extend num (dup (string (rand 10)) (rand 10)))
    (extend num "L")
    (bigint num))
        
(dotimes (i N)
    (setq x (get-bignum (rand 30)))
    (setq y (get-bignum (rand 30)))
    ;(println "x=" x " y=" y)
    (print i "      \r")

    (unless (and
        (= (/ x x) 1L)
        (= (/ y y) 1L)
        )
            (println ">>>>> ERROR in x/x y/y " x " " y)
            (exit))
    
    (setq x+y (+ x y))
    (setq x-y (- x y))

    (setq x*y (* x y))
    (setq x/y (/ x y))

    (unless (and (= (- x+y y) x) (= (- x+y x) y) (= (+ x-y y) x) ) 
            (println ">>>>> ERROR in +, - with " x " " y)
            (exit))

    (unless (and (= (/ x*y x) y) (= (/ x*y y) x)) 
        (println ">>>>> ERROR in * / with:\n" x "\n" y "\nat: " i)
        (println "x*y / x ->" (/ x*y x) )
        (println "x*y / y ->" (/ x*y y) )
        (exit))

    (unless (= (% x y) (- x (* x/y y)))
            (println ">>>>> ERROR in %, * , / operation with " x " " y)
            (exit))

    (when (> (abs x/y) 0)
        ;(println x " " y " remainder " (- (abs x) (* (abs x/y) (abs y))))
        (unless (< (- (abs x) (* (abs x/y) (abs y))) (abs y))
            (println ">>>>> ERROR in abs, -, *, - with " x " " y)
            (exit))
    )

)

(println ">>>>> abs, float, bigint, +, -, *, /, % big integers tested SUCCESSFUL")

(exit)

;; eof    
